# -*- coding: utf-8 -*-
"""Reality_Defender_API_caller.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1RBiVBdugAv6SwlbCUyh8N9cKdDGmASrr
"""

# Block P1 — Install SDK and Imports
# ------------------------------------------------------------
# Purpose:
# - Install the Reality Defender SDK from PyPI (pinned to a known working version).
# - Import only what is needed for a small proof of concept.
# - Apply nest_asyncio so asyncio can run inside Colab cells without issues.
#
# Notes:
# - If Reality Defender releases newer SDKs later, you can relax the pin or bump it explicitly.

!pip -q install realitydefender==0.1.9 nest_asyncio

import os
import json
import time
import asyncio
from getpass import getpass
from google.colab import files  # Colab's simple upload widget

import nest_asyncio
nest_asyncio.apply()

# SDK imports
from realitydefender import RealityDefender
try:
    # Some SDK versions export a typed error. If not present, we define a fallback.
    from realitydefender import RealityDefenderError
except Exception:
    class RealityDefenderError(Exception):
        """Fallback error class used when the SDK does not export its own error type."""
        pass

# Print the SDK version for traceability
try:
    from importlib.metadata import version as _pkg_version
    print("realitydefender version:", _pkg_version("realitydefender"))
except Exception:
    print("realitydefender version: unknown")

# Block P2 — API Key (safe input)
# ------------------------------------------------------------
# Purpose:
# - Load the Reality Defender API key from the environment if it is already set.
# - Otherwise prompt once and store it in the environment for this runtime.
#
# Guidance:
# - Never hard-code API keys inside notebooks.
# - If you restart your runtime, you will need to re-enter the key unless you set it in the environment again.

API_KEY = os.getenv("REALITY_DEFENDER_API_KEY")
if not API_KEY:
    API_KEY = getpass("Enter Reality Defender API key (input is hidden): ").strip()
    if not API_KEY:
        raise SystemExit("No API key provided. Please rerun and enter a key.")
    os.environ["REALITY_DEFENDER_API_KEY"] = API_KEY

print("API key loaded.")

# Block P3 — Upload One Audio File and Validate Before Any API Call
# ------------------------------------------------------------
# Purpose:
# - Let the user upload a single audio file into this Colab session.
# - Validate that the file type and size meet the documented free trial limits
#   BEFORE making any network call to Reality Defender.
#
# Why this matters:
# - The free trial has a monthly quota. Running validation first prevents wasting calls
#   on files that will be rejected for size or type later.
#
# Limits pulled from vendor documentation (free tier focus):
# - Allowed audio extensions: flac, wav, mp3, m4a, aac, alac, ogg
# - Maximum size: 20 MB

from typing import Set

ALLOWED_EXTS: Set[str] = {".flac", ".wav", ".mp3", ".m4a", ".aac", ".alac", ".ogg"}
MAX_MB = 20
MAX_BYTES = MAX_MB * 1024 * 1024

def human_bytes(n: int) -> str:
    """Return a human readable size string for a given byte count."""
    units = ["B", "KB", "MB", "GB", "TB"]
    size = float(n)
    i = 0
    while size >= 1024 and i < len(units) - 1:
        size /= 1024
        i += 1
    return f"{size:.2f} {units[i]}"

def validate_audio_local(path: str) -> None:
    """
    Validate the file locally before any API call.

    Rules:
      - Extension must be in ALLOWED_EXTS.
      - Size must be <= MAX_BYTES.

    Raises:
      SystemExit with a clear message if validation fails.
    """
    if not os.path.exists(path):
        raise SystemExit(f"File not found: {path}")

    ext = os.path.splitext(path)[1].lower()
    if ext not in ALLOWED_EXTS:
        allowed = ", ".join(sorted(ALLOWED_EXTS))
        raise SystemExit(f"Unsupported extension '{ext}'. Allowed: {allowed}")

    size = os.path.getsize(path)
    if size > MAX_BYTES:
        raise SystemExit(
            f"File is too large: {human_bytes(size)}. The free tier limit is {MAX_MB} MB."
        )

print("Upload one audio file (<= 20 MB).")
uploaded = files.upload()
if not uploaded:
    raise SystemExit("No file uploaded.")

# Use the first selected file
FILENAME = next(iter(uploaded.keys()))
FILEPATH = os.path.abspath(FILENAME)

# Validate locally before any API call
validate_audio_local(FILEPATH)

# If we reach here, basic validation passed
_size = os.path.getsize(FILEPATH)
print(f"Using: {os.path.basename(FILEPATH)} — {human_bytes(_size)} (pre-validation passed)")

# Block P4 — Submit (async upload) and Poll With Progress and Total Timeout
# ------------------------------------------------------------
# Purpose:
# - Force the asynchronous flow for better control in notebooks.
# - Submit the file and receive a request_id.
# - Poll for the result using timed "slices" so we can show progress and enforce an overall timeout.
#
# Operator guidance:
# - If a file is long or the service is under load, processing can take several minutes.
# - The code below uses:
#     TOTAL_TIMEOUT_SEC = 360  (total time cap)
#     SLICE_TIMEOUT_SEC = 20   (wait per slice before printing a dot)
# - If you hit the total timeout, you can re-run this cell to continue waiting on the same request_id
#   without re-uploading. The request remains valid server-side.

TOTAL_TIMEOUT_SEC = 360
SLICE_TIMEOUT_SEC = 30

rd = RealityDefender(api_key=os.environ["REALITY_DEFENDER_API_KEY"])

async def submit_upload(fp: str) -> str:
    """
    Submit the audio file to Reality Defender and return the request_id.

    Raises:
      RealityDefenderError if the SDK does not return a request_id.
    """
    print("Submitting upload to Reality Defender...")
    r = await rd.upload(file_path=fp)
    rid = r.get("request_id")
    if not rid:
        raise RealityDefenderError("upload() did not return a request_id")
    print(f"Upload successful. request_id={rid}")
    return rid

REQUEST_ID = asyncio.get_event_loop().run_until_complete(submit_upload(FILEPATH))

async def poll_with_progress(rid: str) -> dict:
    """
    Poll for a result using the SDK's get_result(request_id) in timed slices.

    Behavior:
      - Each slice awaits get_result for up to SLICE_TIMEOUT_SEC seconds.
      - If the slice times out, a dot is printed to indicate progress and the loop continues.
      - The loop enforces a hard total timeout of TOTAL_TIMEOUT_SEC to prevent indefinite hangs.

    Returns:
      The final result dict from Reality Defender upon completion.

    Raises:
      asyncio.TimeoutError if TOTAL_TIMEOUT_SEC elapses before completion.
      RealityDefenderError for SDK-declared fatal errors.
      RuntimeError for unexpected exceptions.
    """
    print(f"Waiting for result (total timeout {TOTAL_TIMEOUT_SEC}s, slice {SLICE_TIMEOUT_SEC}s)...")
    start = time.time()
    slices = 0

    while True:
        elapsed = time.time() - start
        if elapsed >= TOTAL_TIMEOUT_SEC:
            raise asyncio.TimeoutError(
                f"Timed out after {TOTAL_TIMEOUT_SEC} seconds waiting for result."
            )

        try:
            # Let the SDK poll internally for up to SLICE_TIMEOUT_SEC.
            res = await asyncio.wait_for(rd.get_result(rid), timeout=SLICE_TIMEOUT_SEC)
            return res  # Completed within the current slice

        except asyncio.TimeoutError:
            # Slice timed out: job likely still processing server-side. Print a dot and continue.
            slices += 1
            print(".", end="", flush=True)
            # Loop continues until total timeout is reached.

        except RealityDefenderError as e:
            # SDK reported a known fatal error. Surface it cleanly.
            raise

        except Exception as e:
            # Unknown or transient error. Surface with context and stop.
            raise RuntimeError(f"Polling failed after {slices} slices: {type(e).__name__}: {e}") from e

def print_compact_result(tag: str, result: dict) -> None:
    """
    Print a compact, readable summary suitable for both analysts and engineers.

    Displays:
      - Overall status and score.
      - Per-model status and score.
      - A truncated preview of the raw JSON.
    """
    status = result.get("status")
    score = result.get("score")

    print(f"\n{tag}")
    print(f"Overall status: {status}")
    if isinstance(score, (int, float)):
        print(f"Overall score:  {score:.3f}")
    else:
        print(f"Overall score:  {score}")

    models = result.get("models") or []
    if models:
        print("Models:")
        for m in models:
            name = m.get("name")
            mstat = m.get("status")
            mscore = m.get("score")
            if isinstance(mscore, (int, float)):
                print(f"  - {name}: {mstat} (score={mscore:.3f})")
            else:
                print(f"  - {name}: {mstat} (score={mscore})")

    # Engineer-friendly JSON preview
    s = json.dumps(result, ensure_ascii=False, indent=2)
    limit = 2000
    print("\nRaw JSON (truncated preview)")
    print(s if len(s) <= limit else s[:limit] + "...\n[truncated]")

# Execute polling
t0 = time.time()
try:
    RESULT = asyncio.get_event_loop().run_until_complete(poll_with_progress(REQUEST_ID))
    dt = time.time() - t0
    print_compact_result(f"Result received in {dt:.2f} seconds", RESULT)

except asyncio.TimeoutError as e:
    # If this happens, you can re-run this cell to keep waiting on the same REQUEST_ID
    # without re-uploading the file or consuming another upload call.
    raise SystemExit(str(e))

except RealityDefenderError as e:
    # SDK-declared fatal error
    raise SystemExit(f"RealityDefenderError: {e}")

except Exception as e:
    # Any other unexpected exception
    raise SystemExit(f"Unexpected error: {type(e).__name__}: {e}")

# Block P5 — Save Result to File (Optional, Manual Export)
# ------------------------------------------------------------
# Purpose:
# - Save the full raw JSON response to a local file so you can inspect it later,
#   re-check model scores, or compare runs over time.
# - Writes to /content so the file is downloadable from the left file panel in Colab.
#
# Output:
#   /content/rd_result_<timestamp>.json

from datetime import datetime

def save_result_json(result: dict, prefix: str = "rd_result") -> str:
    """
    Save the result JSON to a timestamped file in /content.
    Returns the full file path.
    """
    ts = datetime.now().strftime("%Y%m%d_%H%M%S")
    out_path = f"/content/{prefix}_{ts}.json"
    with open(out_path, "w", encoding="utf-8") as f:
        json.dump(result, f, ensure_ascii=False, indent=2)
    return out_path

if "RESULT" not in globals():
    raise SystemExit("No RESULT found. Please run Block P4 first.")

output_path = save_result_json(RESULT)
print(f"Saved result to: {output_path}")

# Optional: preview entire file if you want to scroll through
# Uncomment to show the full JSON
# with open(output_path, "r", encoding="utf-8") as f:
#     print(f.read())